<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shareong</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shareong.me/"/>
  <updated>2017-07-10T13:55:13.818Z</updated>
  <id>http://shareong.me/</id>
  
  <author>
    <name>Shareong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仰望天空，云卷云舒</title>
    <link href="http://shareong.me/stargazing-leayh.html"/>
    <id>http://shareong.me/stargazing-leayh.html</id>
    <published>2017-07-09T16:00:00.000Z</published>
    <updated>2017-07-10T13:55:13.818Z</updated>
    
    <content type="html"><![CDATA[<p><center><br>今天前，辛苦并快乐着<br>闲步、听歌、耕耘书行<br>今天前，关心朋友和亲人<br>我有一扇窗户，仰望天空，云卷云舒<br>今天前，为每一次不幸祷告<br>祈愿以后我的幸福<br>仁慈的父告诉我的<br>我将告诉每一个不幸的人<br>为每一捧风每一寸彩霞找一个惬意的归宿<br>不相识的情侣，我也会祝福<br>愿你们执手偕老<br>愿你们有才人功成名就<br>愿你们在阳光下沐浴幸福<br>今天前，仰望天空，云卷云舒<br>这样<br>怀着希望<br>明天，面朝大海，春暖花开<br></center></p>
<p><center><br><img src="http://ospmkbjow.bkt.clouddn.com/leayh.jpg?imageView2/2/w/1000/h/400/q/75|imageslim" alt="leayh"><br></center></p>
<hr>
<p>　　这是我中学时代模仿海子《面朝大海，春暖花开》写的一篇日志，愿当时的那颗赤子之心能够陪伴我继续前行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;br&gt;今天前，辛苦并快乐着&lt;br&gt;闲步、听歌、耕耘书行&lt;br&gt;今天前，关心朋友和亲人&lt;br&gt;我有一扇窗户，仰望天空，云卷云舒&lt;br&gt;今天前，为每一次不幸祷告&lt;br&gt;祈愿以后我的幸福&lt;br&gt;仁慈的父告诉我的&lt;br&gt;我将告诉每一个不幸的人&lt;br&gt;为每一捧风每一
    
    </summary>
    
    
      <category term="随笔" scheme="http://shareong.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="http://shareong.me/Single-Number.html"/>
    <id>http://shareong.me/Single-Number.html</id>
    <published>2017-07-06T11:24:49.000Z</published>
    <updated>2017-07-08T06:10:35.056Z</updated>
    
    <content type="html"><![CDATA[<p>　　该系列的三个题目都来自 <a href="https://leetcode.com/problems/single-number/#/description" target="_blank" rel="external">LeetCode</a>，本文介绍了自己的几个复杂度较低的解决思路，如有不恰当的地方欢迎指出，或者你有更好的方法，期待与你讨论。</p>
<h2 id="Single-Number-I"><a href="#Single-Number-I" class="headerlink" title="Single Number I"></a>Single Number I</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　给定一个整形数组，数组中的元素除了某一个数只出现了一次，其它的数都出现了两次，找出这个单独出现的数。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>　　这种题目可以扩展描述为：一个整形数组中只有一个元素出现了奇数次，其它的元素都出现了偶数次。这类问题比较简单，只需要一个异或(xor)操作就能解决了。设A为一个整数，那么     </p>
<p><center>A xor A = 0, A xor 0 = A</center><br>　　根据上面描述的性质，我们只需将数组里所有的元素进行异或，得到的结果就是要找的那个数。</p>
<h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int ans = 0;</div><div class="line">        for(int i = 0; i &lt; nums.size(); i++)</div><div class="line">            ans ^=  nums[i];</div><div class="line">        return ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　给定一个整形数组，数组中的元素除了某一个数只出现了一次，其它的数都出现了三次，找出这个单独出现的数。</p>
<h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p>　　这一题有两种复杂度为O(n)的解决方法，都是通过位操作实现。第一种是最容易理解的，创建一个整形数组c[sizeof(int)]，用c[i]去记录给定数组中第i位（二进制位）为1的元素个数，再对c[i]进行mod3操作，最后c[]其实就是要找的那个数的二进制展开。<br>　　这里着重介绍第二种方法，因为用到了状态机的思想，比较好玩，而且代码精简。用one记录处理到当前元素为止，哪些二进制位1出现了1(mod3)次，用two记录哪些二进制位1出现了2(mod3)次。处理到最后，one记录的就是最终结果，two必然为0。这里有一个难点就是状态转移，这里我用两张图来表示one和two遇到0和1的一个状态变化（注：因为都是mod3操作，所以就不用考虑one和two同为1的状态，而且也不会出现这种状态）。<br>　　<center><img src="http://ospmkbjow.bkt.clouddn.com/Single_number_2.png" alt="single number 2"></center><br>　　看到这个图是不是一下子想起了卡诺图化简呢，然后我们得到如下的两个状态转移公式：<br>　　<code>one = (Bit ^ one &amp; ~two) | (Bit &amp; ~one &amp; ~two)</code><br>　　<code>two = (~Bit &amp; ~one &amp; two) | (Bit &amp; one &amp; ~two)</code></p>
<h3 id="代码展示-1"><a href="#代码展示-1" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int one = 0, two = 0, temp;</div><div class="line">    	for (int i = 0; i &lt; nums.size(); i++) &#123;</div><div class="line">            temp = one;   // Record the original state of one</div><div class="line">            one = (nums[i] ^ temp &amp; ~two) | (nums[i] &amp; ~temp &amp; ~two);</div><div class="line">            two = (~nums[i] &amp; ~temp &amp; two) | (nums[i] &amp; temp &amp; ~two);</div><div class="line">        &#125;</div><div class="line">	    return one;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>　　给定一个整形数组，数组中的元素除了某两个数只出现了一次，其它都出现了两次，找出这个两个单独出现的数。<br>　　例如给一个数组<code>nums = [1, 2, 1, 3, 2, 5]</code>，返回<code>[3, 5]</code>。</p>
<h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><p>　　本题和上面的题目一样，考察的仍然是位操作，而且同样能以O(n)的复杂度解决。本题和Single Number I 相似，解法也差不多，只不过要多绕一个弯子。首先我们想到的还是将数组所有的元素进行异或，假设A和B是我们要找的那两个数，那么异或的结果C就是<code>A oxr B</code>。C该怎么去用呢，这就是本题的难点。我们将C二进制展开，假如低位的8个bit是<code>01001000</code>，其中第4位和第7位（从低位向高位数）为1，那就意味着A和B在第4位和第8位具有不同的bit，我们把最低位的这一bit取出来，这里就是把第4位取出，然后用它将数组中的元素分为两类，一类就是该位的bit值为1，另一类为0，最后将这两类分别异或，就得到了我们要的结果。</p>
<h3 id="代码展示-2"><a href="#代码展示-2" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        int axorb = 0, l = nums.size();</div><div class="line">        for(int i = 0; i &lt; l; i++)</div><div class="line">            axorb ^= nums[i];</div><div class="line">        int lastbit = axorb ^ (axorb &amp; (axorb - 1)); // find a bit that a differs b</div><div class="line">        int a = 0, b = 0;</div><div class="line">        for(int i = 0; i &lt; l; i++)&#123;</div><div class="line">            if(nums[i] &amp; lastbit) a ^= nums[i];</div><div class="line">            else b ^= nums[i];</div><div class="line">        &#125;</div><div class="line">        return vector&lt;int&gt;&#123;a, b&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　该系列的三个题目都来自 &lt;a href=&quot;https://leetcode.com/problems/single-number/#/description&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode&lt;/a&gt;，本文介绍了自己的几个复
    
    </summary>
    
    
      <category term="Array" scheme="http://shareong.me/tags/Array/"/>
    
      <category term="Coding" scheme="http://shareong.me/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>如何使用MathJax引擎在博客中插入数学公式</title>
    <link href="http://shareong.me/Mathjax-Introduction.html"/>
    <id>http://shareong.me/Mathjax-Introduction.html</id>
    <published>2017-07-05T16:00:00.000Z</published>
    <updated>2017-07-07T13:06:05.297Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h3 id="Mathjax简介"><a href="#Mathjax简介" class="headerlink" title="Mathjax简介"></a>Mathjax简介</h3><p>　　<a href="https://www.mathjax.org/" target="_blank" rel="external">MathJax</a>是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便地在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。</p>
<h3 id="Mathjax获取"><a href="#Mathjax获取" class="headerlink" title="Mathjax获取"></a>Mathjax获取</h3><p>　　获取Mathjax最简单的方法就是通过使用分布式网络服务中的MathJax的副本，它位于cdn.mathjax.org。采用这种方式，你只需要在编辑Markdown文档时，在正文最前面插入（注：插入的位置是在文档属性与正文之间，而不是在第一行）如下的javascript代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; async</div><div class="line">  src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="编辑LaTex公式"><a href="#编辑LaTex公式" class="headerlink" title="编辑LaTex公式"></a>编辑LaTex公式</h3><p>　　这里就不在赘述LaTex公式编辑的基本语法了，唯一要强调的就是MathJax中的公式排版有两种方式，Inline和Displayed。Inline表示在行内显示公式，定界符是<code>\(...\)</code>；Display表示单独一行显示公式，定界符是<code>$$...$$</code>。例如我们编辑一个行内公式\(x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\)，它的LaTex内容如下,注意需要转义<code>\</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\(x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;\\)</div></pre></td></tr></table></figure></p>
<p>　　如果我们要编辑一个行间公式，例如$$x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$<br>　　它的LaTex内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$x=\frac&#123;-b\pm\sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125;$$</div></pre></td></tr></table></figure></p>
<p>更多的公式编辑技巧参考：</p>
<blockquote>
<p><a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/" target="_blank" rel="external">Mathjax与LaTex公式简介</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;Mat
    
    </summary>
    
    
      <category term="教程" scheme="http://shareong.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
